---
title: "Useful Time Series Functions"
output: html_notebook
---

53X is useful for when there are MAJOR outliers in the data. This goes through a cycle of taking the medians of small subsets of the data and filters out data points that are misleading in your analysis

```{r}
five_three_x <- function(X){
  Y <- rep(NA, length(X)-4)
  for(i in 3:(length(X)-2)){
    Y[i] <- median(X[(i-2) : (i+2)])
  }
  
  Z <- rep(NA, length(Y)-2)
  for(j in 2:(length(Y)-1)){
    Z[j] <- median(Y[(j-1) : (j+1)])
  }
  
  W <- rep(NA, length(Z)-2)
  for(k in 2:(length(Z)-1)){
    W[k] <- median(Z[(k-1) : (k+1)])
  }
  leftover <- rep(NA, (length(X)-length(W)))
  W = c(W,leftover)
  return(W)
}
```



This is an algorithm that tries to follow the general pattern in the data while ignoring potentially noisy data points. It can follow a constant, linear, or quadratic form where the higher up in degree you go, the more flexible it is but may become overfit to noise in the data. You can use it to make predictions a couple steps ahead. May need some cleaning before using it on the data. 

```{r}
exponential_smoothing <- function(X,order,num_preds){
  
  alpha = 0.1
  predictions <- rep(0, num_preds)
  
  if(order == 0){
    ahat_0 <- rep(NA, length(X))
    ahat_0[1] <- X[1]
    pred_0 <- rep(NA,length(X))
    errs_0 <- rep(NA,length(X))
    
    for(j in 2:length(X)){
      pred_0[j] <- ahat_0[j-1]
      errs_0[j] <- X[j]-ahat_0[j-1]
      ahat_0[j] <- ahat_0[j-1] + (alpha*errs_0[j])
    }
    
    for(i in 1:num_preds){
      predictions[i] <- ahat_0[length(X)]
    }
    
    final <- c(pred_0, predictions)
    return(final)
  }
  
  if(order == 1){
    ahat_1 <- rep(NA, length(X))
    bhat_1 <- rep(NA, length(X))
    ahat_1[1] <- X[1]
    bhat_1[1] <- 0
    
    pred_1 <- rep(NA,length(X))
    errs_1 <- rep(NA,length(X))
    
    for(j in 2:length(X)){
      pred_1[j] <- ahat_1[j-1] + bhat_1[j-1]
      errs_1[j] <- X[j]-ahat_1[j-1]
      ahat_1[j] <- ahat_1[j-1] + bhat_1[j-1] + (2*alpha - alpha^2)*errs_1[j]
      bhat_1[j] <- bhat_1[j-1] + ((alpha^2)*errs_1[j])
    }
    
    for(i in 1:num_preds){
      predictions[i] <- ahat_1[length(X)] + (bhat_1[length(X)]*i)
    }
    
    final <- c(pred_1, predictions)
    return(final)
  }
  
  if(order == 2){
    ahat_2 <- rep(NA, length(X))
    bhat_2 <- rep(NA, length(X))
    chat_2 <- rep(NA, length(X))
    ahat_2[1] <- X[1]
    bhat_2[1] <- 0
    chat_2[1] <- 0
    
    pred_2 <- rep(NA,length(X))
    errs_2 <- rep(NA,length(X))
    
    for(j in 2:length(X)){
      pred_2[j] <- ahat_2[j-1] + bhat_2[j-1] + chat_2[j-1]
      errs_2[j] <- X[j]-ahat_2[j-1]
      ahat_2[j] <- ahat_2[j-1] + bhat_2[j-1] + chat_2[j-1] + alpha*(3 - 3*alpha + alpha^2)*errs_2[j]
      bhat_2[j] <- bhat_2[j-1] + 2*chat_2[j-1] + (3*(alpha^2)*(1-(alpha/2))*errs_2[j])
      chat_2[j] <- chat_2[j-1]+((alpha^3)/2)*errs_2[j]
    }
    for(i in 1:num_preds){
      predictions[i] <- ahat_2[length(X)] + (bhat_2[length(X)]*i) + (chat_2[length(X)]*i^2)
    }
    
    final <- c(pred_2, predictions)
    return(final)
  }
}

```


This is a function that will return the mean and variance of a set of time series data. The variance of time series data is calculated differently from independent data so I would recommend using this function to make sure that you are using the correct value.
```{r}
sample_mean_and_variance <- function(X){
  sample_mean = sum(X)/length(X)
  
  step = 0
  total = 0
  for(i in 1:length(X)){
    step = (X[i]-sample_mean)^2
    total = total + step
  }
  sample_variance = total/length(X)
  mean_and_var <- data.frame(sample_mean = sample_mean, sample_var = sample_variance)
  return(mean_and_var)
}
```



```{r}
moving_average <- function(Xt, l){
  moving_average <- rep(NA, length(Xt))
  
  for(i in 1:length(Xt)){
    if(i-l<1){
      temp <-c(Xt[1:(i+l)],Xt[(length(Xt)-(l-i)):(length(Xt))])
      moving_average[i] <-sum(temp)/((2*l)+1)
    }
    else if(i+l > length(Xt)){
      temp <- c(Xt[(i-l):(length(Xt))], Xt[1:((l+i)-length(Xt))])
      moving_average[i] <- sum(temp)/((2*l)+1)
    }
    else{
      temp <- Xt[(i-l): (i+l)]
      moving_average[i] <- sum(temp)/((2*l)+1)
    }
  }
  return(moving_average)
}
```